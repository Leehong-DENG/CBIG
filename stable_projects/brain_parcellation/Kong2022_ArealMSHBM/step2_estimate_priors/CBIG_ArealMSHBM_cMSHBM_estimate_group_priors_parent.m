function Params = CBIG_ArealMSHBM_cMSHBM_estimate_group_priors_parent(project_dir, mesh, ...
     num_sub, num_sess, num_clusters, beta, tmp_dir, max_iter)

% Params = CBIG_ArealMSHBM_cMSHBM_estimate_group_priors_parent(project_dir,mesh,num_sub, ...
% num_sess,num_clusters,beta,tmp_dir, max_iter)
%
% This is the parent script to estimate group priors for strictly contiguous individual
% areal-level parcellation generation. To speed things up, we parallize the script
% as parent and child scripts with multiple CPUs. This training step requires multiple
% CPUs to run. For num_sub training subjects, user should submit 1 parent job and
% num_sub child jobs. 
%
% The estimated group priors include:
% 1) inter-subject functional connectivity variability -- Params.epsil
% 2) group-level connectivity profiles for each parcel -- Params.mu
% 3) intra-subject functional connectivity variability -- Params.sigma
% 4) spatial prior which denotes the probability of each parcel occurring
%    at each location -- Params.theta
%
% To estimate the group priors, we use a group-level areal-level parcellation to
% initialize parameters, which are saved in project_dir/group/group.mat.
%
% The functional connectivity profiles of num_sub training subjects with 
% num_sess sessions are assumed already generated. The lists of functional 
% connectivity profiles for fsaverage space are saved in 
% project_dir/profile_list/training_set/lh_sess<?>.txt
% project_dir/profile_list/training_set/rh_sess<?>.txt.
% The lists of functional connectivity profiles for fs_LR_32k space are saved in
% project_dir/profile_list/training_set/sess<?>.txt
%
% Input:
%   - project_dir:
%
%     The project directory.
%     1) project_dir/group/group.mat 
%        contains the initialization parameters generated by a given group-level
%        parcellation. This file is assumed to be pre-computed before running 
%        the current script.
%        "group.mat" includes the von Mises-Fisher mean direction parameter
%        "mtc". If the dimension of functional connectivity profile
%        is NxD, then "mtc" should be num_clustersxD.
%
%     2) project_dir/profile_list/training_set/lh_sess<?>.txt
%        project_dir/profile_list/training_set/rh_sess<?>.txt
%        or
%        project_dir/profile_list/training_set/sess<?>.txt
%        contain the functional connectivity profile lists for each session. 
%        The functional connectivity profiles are assumed to be pre-computed 
%        before running the current script. These profile lists are assumed 
%        to be pre-generated. For S training subjects and T sessions, there
%        should be T lh_sess<?>.txt and rh_sess<?>.txt lists for data in
%        'fsaverage4/fsaverage5/fsaverage6/fsaverage', or T sess<?>.txt
%        lists for data in 'fs_LR_32k'.
%        For example:
%        project_dir/profile_list/training_set/lh_sess1.txt
%        project_dir/profile_list/training_set/rh_sess1.txt
%        project_dir/profile_list/training_set/lh_sess2.txt
%        project_dir/profile_list/training_set/rh_sess2.txt
%        or
%        project_dir/profile_list/training_set/sess1.txt
%        project_dir/profile_list/training_set/sess2.txt
%        for 2 sessions. Each list should contain S rows, where each row 
%        is the full file path of the functional connectivity profile for 
%        each test subject.
%
%     3) project_dir/spatial_mask/spatial_mask_<mesh>.mat
%        contains the radius spatial mask for the group-level parcellation
%        which is used to initialize the model in 
%        CBIG_ArealMSHBM_generate_ini_params.m. We provide pre-computed 30mm
%        radius mask for Schaefer parcellations in fs_LR_32k and
%        fsaverage6:
%        ./lib/spatial_mask/???/spatial_mask_fs_LR_32k.mat
%        ./lib/spatial_mask/???/spatial_mask_fsaverage6.mat
%
%   - mesh: (string)
%     
%     The data surface space. 'fsaverage5/fsaverage6/fsaverage' or 
%     'fs_LR_32k'. 
%
%   - num_sub: (string)
%
%     The number of subjects the user want to use to estimate the group
%     priors. For example, '40'.
%
%   - num_sess: (string)
%
%     The number of sessions the user want to use to estimate the group
%     priors. For example, '4'.
%
%   - num_clusters: (string)
%
%     The number of parcels of the parcellations. For example, '400'.
%
%   - beta: (string)
%
%     The weight for the gradient-based spatial localization prior. For
%     example, '100'.
%
%   - tmp_dir: (string)
%
%     The directory to save temporary results.
%
%   - max_iter: (string)
%     
%     The maximum iteration of the algorithm. Default is '50'.
%
% Output:
%   
%   - Params: (struct)
%     
%     D: data dimension
%     N: #vertices
%     L: #parcels
%     S: #subjects
%     T: #sessions
%
%     Params.mu: DxL. 
%     The group-level functional connectivity profiles of parcels.
%
%     Params.epsil: 1xL. 
%     The inter-subject concentration parameter, which represents
%     inter-subject functional connectivity variability. A large epsil_l 
%     indicats low inter-subject functional connectivity variability for 
%     parcel l.
%    
%     Params.s_psi: DxLxS. 
%     The functional connectivity profiles of L parcels for S subjects.
%
%     Params.sigma: 1xL. 
%     The intra-subject concentration parameter, which represents
%     intra-subject functional connectivity variability. A large sigma_l
%     indicates low intra-subject functional connectivity variability for
%     parcel l.
%
%     Params.s_t_nu: DxLxTxS. 
%     The functional connectivity profiles of L parcels for S subjects 
%     and each subject has T sessions.
%
%     Params.kappa: 1xL. 
%     The inter-region concentration parameter, which represents
%     inter-region functional connectivity variability. A large kappa_l 
%     indicates low inter-region functional variability for parcel l. 
%     However, please note in this script, we assume kappa to be the same 
%     across parcels.
%
%     Params.s_lambda: NxLxS. 
%     The posterior probability of the individual-specific parcellation of 
%     each subject. 
%
%     Params.theta: NxL. 
%     The spatial prior denotes the probability of parcels occurring at 
%     each spatial location.
%
% Example:
%   Params = CBIG_ArealMSHBM_cMSHBM_estimate_group_priors_parent(project_dir,...
%   'fsaverage6','3','4','400','5','/project_dir/tmp_results');
%
% Written by Ru(by) Kong and CBIG under MIT license: https://github.com/ThomasYeoLab/CBIG/blob/master/LICENSE.md

addpath(fullfile(getenv('CBIG_CODE_DIR'), 'stable_projects', 'brain_parcellation', 'Kong2019_MSHBM', 'lib'));
addpath(fullfile(getenv('CBIG_CODE_DIR'), 'stable_projects', 'brain_parcellation', 'Kong2022_ArealMSHBM', 'lib'));

if(nargin == 8)
    if(isempty(max_iter))
        max_iter = 10;
    else
        max_iter = str2num(max_iter);
    end
else
    max_iter = 10;
end

%% setting parameters
setting_params.num_sub = str2double(num_sub);
setting_params.mesh = mesh; 
setting_params.num_session = str2double(num_sess);
setting_params.num_clusters = str2double(num_clusters);
setting_params.epsilon = 1e-4;
setting_params.beta = str2double(beta);
setting_params.tmp_dir = tmp_dir;
setting_params.radius = 30;
setting_params.group = fullfile(project_dir,'group','group.mat');

if(~exist([setting_params.tmp_dir]))
    mkdir([setting_params.tmp_dir]);
else
    rmdir(setting_params.tmp_dir, 's');
    mkdir([setting_params.tmp_dir]);
end 

%% read in data path
fetch_data(project_dir, setting_params.num_session, setting_params.num_sub, setting_params.mesh, tmp_dir);
fprintf('read data...DONE!\n')

%% parameter initialization
% load group parcellation and parameters 
group = load(setting_params.group);
setting_params.dim = size(group.mtc,1) - 1;

% save the basic parameters and pass them to children
save([setting_params.tmp_dir '/setting_params.mat'],'setting_params');
   

%% paramter initialization

setting_params.g_mu = group.mtc;
if(setting_params.dim == 1482 )
    ini_val = 650;
else   
    ini_val = CBIG_ArealMSHBM_initialize_concentration(setting_params.dim);
end
Params.ini_val = ini_val;
Params.sigma = ini_val*ones(1,setting_params.num_clusters);
Params.s_psi = repmat(setting_params.g_mu,1,1,setting_params.num_sub);
Params.epsil = ini_val*ones(1,setting_params.num_clusters);
Params.mu = setting_params.g_mu;
Params.kappa = ini_val*ones(1,setting_params.num_clusters);
Params.s_t_nu = repmat(setting_params.g_mu,1,1,setting_params.num_session,setting_params.num_sub);

for s = 1:setting_params.num_sub
    ini_s_lambda = load_until_exist([setting_params.tmp_dir '/ini/sub' num2str(s) '.mat']);
    s_lambda(:,:,s) = ini_s_lambda.ini_s_lambda;
    mask(:,:,s) = ini_s_lambda.mask;
end

% read in pre-computed 30mm raidus mask
load(fullfile(project_dir,'spatial_mask',['spatial_mask_' mesh '.mat']));
fprintf('read spatial mask...DONE!\n');
lh_boundary = full(lh_boundary);
rh_boundary = full(rh_boundary);
boundary_mask = [lh_boundary zeros(size(lh_boundary)); zeros(size(rh_boundary)) rh_boundary];

s_lambda = bsxfun(@times, s_lambda, boundary_mask);
Params.s_lambda = bsxfun(@rdivide,s_lambda,sum(s_lambda,2));
mask_nan = repmat((isnan(sum(Params.s_lambda,2))),1,setting_params.num_clusters,1);
Params.s_lambda(mask) = 0;
Params.s_lambda(mask_nan) = 0;
Params.theta = mean(Params.s_lambda,3);
theta_num = sum(Params.s_lambda~=0,3);
Params.theta(Params.theta~=0) = Params.theta(Params.theta~=0)./theta_num(Params.theta~=0);
Params.theta = Params.theta + eps;

%% EM

stop_inter = 0;
cost_inter = 0;
Params.iter_inter = 0;
while(stop_inter == 0)
    Params.iter_inter = Params.iter_inter+1;
    %% Intra subject variability
    cost=0;
    iter_intra_em = 0;
    stop_intra_em = 0;
    Params.sigma = Params.ini_val*ones(1,setting_params.num_clusters);
    Params.s_psi = repmat(setting_params.g_mu,1,1,setting_params.num_sub);
    while(stop_intra_em == 0)
        iter_intra_em = iter_intra_em + 1;
        Params.iter_intra = iter_intra_em;
        fprintf('It is intra em iteration %d..with last cost %d \n',iter_intra_em, cost);
        Params.kappa = Params.ini_val*ones(1,setting_params.num_clusters);
        Params.s_t_nu = repmat(setting_params.g_mu,1,1,setting_params.num_session,setting_params.num_sub);
        tic;
        Params = vmf_clustering_subject_session(Params,setting_params,boundary_mask);
        toc;        
        fprintf('Intra subject variability level \n');
        Params = intra_subject_var(Params,setting_params);

        update_cost = bsxfun(@times,Params.s_psi,permute(Params.s_t_nu,[1,2,4,3]));
        update_cost = sum(bsxfun(@times,Params.sigma,update_cost),1);
        update_cost = bsxfun(@plus,Cdln(Params.sigma,setting_params.dim),update_cost);
        update_cost = sum(sum(sum(update_cost,2),3),4)+sum(sum(bsxfun(@plus,sum(bsxfun(@times,bsxfun(@times,...
            Params.mu,Params.s_psi),Params.epsil),1),Cdln(Params.epsil,setting_params.dim)),2),3);
        update_cost = update_cost + sum(Params.cost_em);
        if(abs(abs(update_cost-cost)./cost) <= 1e-4)
            stop_intra_em = 1;
            Params.cost_intra = update_cost;
        end
        if(iter_intra_em >= 15)
            stop_intra_em = 1;
            Params.cost_intra = update_cost;
        end
        cost = update_cost;
        if(~exist([setting_params.tmp_dir '/inter_' num2str(Params.iter_inter) '/intra_' num2str(iter_intra_em)...
             '/converge_flag']))
            mkdir([setting_params.tmp_dir '/inter_' num2str(Params.iter_inter) '/intra_' num2str(iter_intra_em)...
             '/converge_flag']);
        end
        save([setting_params.tmp_dir '/inter_' num2str(Params.iter_inter) '/intra_' num2str(iter_intra_em)...
         '/converge_flag/iter_' num2str(iter_intra_em) '.mat'],'iter_intra_em','stop_intra_em');
        save_dump([setting_params.tmp_dir '/inter_' num2str(Params.iter_inter) '/intra_' num2str(iter_intra_em)...
         '/converge_flag/iter_' num2str(iter_intra_em) '.mat']);

    end

    %% Inter subject variability
    fprintf('Inter subject variability level \n');
    Params = inter_subject_var(Params,setting_params);

    update_cost_inter = Params.cost_intra;
    
    Params.Record(Params.iter_inter) = update_cost_inter;
    if(abs(abs(update_cost_inter-cost_inter)./cost_inter) <= 1e-5 || Params.iter_inter >= max_iter)
        stop_inter = 1;
        Params.cost_inter = update_cost_inter;

        % set s_lambda, s_psi, s_t_nu to be empty to save space and time
        Params.s_lambda = [];
        Params.s_psi = [];
        Params.s_t_nu = [];
        save(fullfile(project_dir, 'priors', 'cMSHBM', ['beta' beta], 'Params_Final.mat'),'Params','-v7.3');
        fprintf('Finished!\n');
    end
    cost_inter = update_cost_inter;

    if(~exist([setting_params.tmp_dir '/inter_' num2str(Params.iter_inter) '/converge_flag']))
        mkdir([setting_params.tmp_dir '/inter_' num2str(Params.iter_inter) '/converge_flag']);
    end
    save([setting_params.tmp_dir '/inter_' num2str(Params.iter_inter) '/converge_flag/iter_'...
        num2str(Params.iter_inter) '.mat'],'stop_inter');
    save_dump([setting_params.tmp_dir '/inter_' num2str(Params.iter_inter) '/converge_flag/iter_'...
        num2str(Params.iter_inter) '.mat']);
    
    mkdir(fullfile(project_dir, 'priors', 'cMSHBM',['beta' beta]));
    save(fullfile(project_dir, 'priors', 'cMSHBM',['beta' beta], ['Params_iteration'...
        num2str(Params.iter_inter) '.mat']),'Params','-v7.3');
end
  
rmpath(fullfile(getenv('CBIG_CODE_DIR'), 'stable_projects', 'brain_parcellation', 'Kong2019_MSHBM', 'lib'));
rmpath(fullfile(getenv('CBIG_CODE_DIR'), 'stable_projects', 'brain_parcellation', 'Kong2022_ArealMSHBM', 'lib'));

end
    
    
%% sub-functions
       
function Params = inter_subject_var(Params,setting_params)

% Inter-subject variability level

% update mu
mu_update = sum(Params.s_psi,3);
mu_update = bsxfun(@times,mu_update,1./sqrt(sum((mu_update).^2)));

% update epsil
epsil_update = bsxfun(@times,Params.s_psi,mu_update);
epsil_update = sum(sum(epsil_update,1),3);
epsil_update = epsil_update./setting_params.num_sub;
epsil_update(epsil_update > 1) = 1;
for i = 1:setting_params.num_clusters
    epsil_update(i) = invAd(setting_params.dim,epsil_update(i));
    if(epsil_update(i) < Params.ini_val)
        epsil_update(i) = Params.ini_val;
        fprintf('[WARNING]epsil of %d is less than %d \n',i, Params.ini_val);
    end
    if(isinf(epsil_update(i)))
        epsil_update(i) = Params.epsil(i);
        fprintf('[WARNING]epsil of %d is inf\n',i);
    end
end
Params.mu = mu_update;
Params.epsil = epsil_update;

end
    
function Params = intra_subject_var(Params,setting_params)

% Intra-subject variability level

flag_psi = zeros(setting_params.num_sub,1);
stop_intra = 0;
iter_intra = 0;
while(stop_intra == 0)
    iter_intra = iter_intra + 1;

    % update s_psi
    fprintf('It is inter interation %d intra iteration %d..update s_psi and sigma..\n',Params.iter_inter,iter_intra);
    s_psi_update = sum(bsxfun(@times,Params.s_t_nu,repmat(Params.sigma,size(Params.s_t_nu,1),1,...
        size(Params.s_t_nu,3),size(Params.s_t_nu,4))),3);
    s_psi_update = reshape(s_psi_update,size(s_psi_update,1),size(s_psi_update,2),...
        size(s_psi_update,3)*size(s_psi_update,4));
    s_psi_update = bsxfun(@plus,s_psi_update,bsxfun(@times,Params.epsil,Params.mu));
    s_psi_update = bsxfun(@times,s_psi_update,1./sqrt(sum((s_psi_update).^2)));
    
    for s = 1:setting_params.num_sub
        checkpsi = diag(s_psi_update(:,:,s)'*Params.s_psi(:,:,s));
        checkpsi_flag = (sum(1-checkpsi < setting_params.epsilon) < setting_params.num_clusters);
        if(checkpsi_flag < 1)
            flag_psi(s,1) = 1;
        end
    end
    Params.s_psi = s_psi_update;
    
    % update sigma
    sigma_update = bsxfun(@times,Params.s_psi,permute(Params.s_t_nu,[1,2,4,3]));
    sigma_update = sum(sum(sum(sigma_update,1),3),4)./(setting_params.num_sub*setting_params.num_session);
    sigma_update(sigma_update > 1) = 1;
    for i = 1:setting_params.num_clusters
        sigma_update(i) = invAd(setting_params.dim,sigma_update(i));
        if(sigma_update(i) < Params.ini_val)
            sigma_update(i) = Params.ini_val;
            fprintf('[WARNING]sigma of %d is less than %d \n',i, Params.ini_val);
        end
        if(isinf(sigma_update(i)))
            sigma_update(i) = Params.sigma(i);
            fprintf('[WARNING]sigma of %d is inf\n',i);
        end
    end

    if((sum(flag_psi) == setting_params.num_sub)&&(mean(abs(Params.sigma-sigma_update)./Params.sigma)<...
        setting_params.epsilon))
        stop_intra = 1;
    end
    if(iter_intra > 20)
        stop_intra = 1;
    end
    Params.sigma = sigma_update;
end
end

function Params = vmf_clustering_subject_session(Params,setting_params,boundary_mask)

% Inter-region level

stop_em = 0;
iter_em = 0;
cost = zeros(1,setting_params.num_sub);
while(stop_em == 0)
    tic;
    iter_em = iter_em + 1;
    fprintf('It is EM iteration.. %d..\n',iter_em);
    % Mstep
    flag_nu = zeros(setting_params.num_sub,setting_params.num_session);
    stop_m = 0;
    iter_m = 0;
    if(~exist([setting_params.tmp_dir '/Mstep/converge_flag']))
        mkdir([setting_params.tmp_dir '/Mstep/converge_flag']);
    end

    fprintf('M-step..\n');
    while(stop_m == 0)
        iter_m = iter_m+1;
        fprintf('It is iteration %d update kappa..\n',iter_m);

        s_lambda=Params.s_lambda;
        
        for s = 1:setting_params.num_sub
            tmp_psi = Params.s_psi(:,:,s);
            tmp_sigma = Params.sigma;
            tmp_s_t_nu = Params.s_t_nu(:,:,:,s);
            tmp_s_lambda = Params.s_lambda(:,:,s);
            if(~exist([setting_params.tmp_dir '/Mstep/setting_params']))
                mkdir([setting_params.tmp_dir '/Mstep/setting_params']);
            end
            save([setting_params.tmp_dir '/Mstep/setting_params/sub' num2str(s) '_' num2str(iter_m)...
                 '.mat'], 'tmp_s_lambda','tmp_psi','tmp_sigma','tmp_s_t_nu');
            save_dump([setting_params.tmp_dir '/Mstep/setting_params/sub' num2str(s) '_' num2str(iter_m)...
                 '.mat']);
        end
        
        for s = 1:setting_params.num_sub
            kappa_tmp = load_until_exist([setting_params.tmp_dir '/Mstep/kappa_step1/sub' num2str(s)...
                 '_' num2str(iter_m) '.mat']);
                    
            if(s == 1)
                kappa_update = kappa_tmp.kappa_update_tmp;
            else
                kappa_update = kappa_update + kappa_tmp.kappa_update_tmp;
            end
        end
        kappa_update = kappa_update./sum((setting_params.num_session.*sum(sum(s_lambda,1),3)));
        kappa_update = invAd(setting_params.dim,kappa_update);
        kappa_update = repmat(kappa_update,1,setting_params.num_clusters);
        if (sum(kappa_update == Inf) ~= 0)
            warning('kappa is Inf !\n')
            kappa_update(kappa_update == Inf) = Params.kappa(kappa_update == Inf);
        end
        if (kappa_update < Params.ini_val)
            kappa_update = Params.ini_val;
            fprintf('[WARNING]kappa is less than %d \n', Params.ini_val);
        end
        if(~exist([setting_params.tmp_dir '/Mstep/kappa_step2']))
            mkdir([setting_params.tmp_dir '/Mstep/kappa_step2']);
        end
        save([setting_params.tmp_dir '/Mstep/kappa_step2/kappa_' num2str(iter_m) '.mat'],'kappa_update');
        save_dump([setting_params.tmp_dir '/Mstep/kappa_step2/kappa_' num2str(iter_m) '.mat']);
        
        for s = 1:setting_params.num_sub
            tmp_s_t_nu = load_until_exist([setting_params.tmp_dir '/Mstep/s_t_nu/sub' num2str(s)...
                 '_' num2str(iter_m) '.mat']);
            
            Params.s_t_nu(:,:,:,s) = tmp_s_t_nu.tmp_s_t_nu;
            flag_nu(s,:) = tmp_s_t_nu.flag_nu;
        end
        
        if((sum(sum(flag_nu)) == setting_params.num_sub*setting_params.num_session)&&...
            (mean(abs(Params.kappa-kappa_update)./Params.kappa)<setting_params.epsilon))
            stop_m = 1;
            save([setting_params.tmp_dir '/Mstep/converge_flag/Mstep_converge.mat'],'stop_m');
            save_dump([setting_params.tmp_dir '/Mstep/converge_flag/Mstep_converge.mat']);

        end
        Params.kappa = kappa_update;
        save([setting_params.tmp_dir '/Mstep/converge_flag/iter_' num2str(iter_m) '.mat'],'iter_m','stop_m');
        save_dump([setting_params.tmp_dir '/Mstep/converge_flag/iter_' num2str(iter_m) '.mat']);
    end
    
    % spatial connectness prior    
    for s = 1:setting_params.num_sub
        s_muc_tmp = load_until_exist([setting_params.tmp_dir '/Mstep/s_muc/sub' num2str(s) '.mat']);
        gamma_update_tmp(s) = s_muc_tmp.tmp_gamma;
    end
    
    gamma_update1=nansum(gamma_update_tmp);
    gamma_update2=gamma_update1./sum(sum(sum(s_lambda,1),3));
    
    gamma_update=invAd(3,gamma_update2);
    Params.gamma=gamma_update;
    
    if(~exist([setting_params.tmp_dir '/Mstep/gamma']))
        mkdir([setting_params.tmp_dir '/Mstep/gamma']);
    end
    save([setting_params.tmp_dir '/Mstep/gamma/gamma.mat'], 'gamma_update');
    save_dump([setting_params.tmp_dir '/Mstep/gamma/gamma.mat']);
   
    s_muc = load_until_exist([setting_params.tmp_dir '/Mstep/s_muc/sub' num2str(s) '.mat']);
    Params.s_muc = s_muc.tmp_s_muc;
    

    % Estep
    fprintf('Estep..\n');
    
    for s = 1:setting_params.num_sub
        tmp_s_t_nu = Params.s_t_nu(:,:,:,s);
        tmp_kappa = Params.kappa;
        tmp_theta = Params.theta;
        if(~exist([setting_params.tmp_dir '/Estep/setting_params']))
            mkdir([setting_params.tmp_dir '/Estep/setting_params']);
        end
        save([setting_params.tmp_dir '/Estep/setting_params/sub' num2str(s) '.mat'],...
             'tmp_kappa','tmp_s_t_nu','tmp_theta','setting_params');
        save_dump([setting_params.tmp_dir '/Estep/setting_params/sub' num2str(s) '.mat']);
    end
    for s = 1:setting_params.num_sub
        tmp_estep = load_until_exist([setting_params.tmp_dir '/Estep/s_lambda_step1/sub' num2str(s) '.mat']);
        tmp_estep.tmp_s_lambda(:, CBIG_nansum(tmp_estep.tmp_s_lambda) == 0) = 0;
        Params.s_lambda(:,:,s) = tmp_estep.tmp_s_lambda;
        idx(:,:,s) = tmp_estep.tmp_idx;        
    end
    
    % estimate s_lambda
    Params.s_lambda = bsxfun(@times, Params.s_lambda, boundary_mask);
    Params.s_lambda=bsxfun(@rdivide,Params.s_lambda,sum(Params.s_lambda,2));
    mask_nan=repmat((isnan(sum(Params.s_lambda,2))),1,setting_params.num_clusters,1);
    Params.s_lambda(mask_nan)=0;
    Params.s_lambda(idx)=0;

    % estimate theta
    Params.theta=mean(Params.s_lambda,3);
    
    for s = 1:setting_params.num_sub
        tmp_lambda = Params.s_lambda(:,:,s);
        if(~exist([setting_params.tmp_dir '/Estep/s_lambda_step2']))
            mkdir([setting_params.tmp_dir '/Estep/s_lambda_step2']);
        end
        save([setting_params.tmp_dir '/Estep/s_lambda_step2/sub' num2str(s) '.mat'], 'tmp_lambda');
        save_dump([setting_params.tmp_dir '/Estep/s_lambda_step2/sub' num2str(s) '.mat']);
    end
    tmp_theta = Params.theta;
    if(~exist([setting_params.tmp_dir '/Estep/theta']))
        mkdir([setting_params.tmp_dir '/Estep/theta']);
    end
    save([setting_params.tmp_dir '/Estep/theta/theta.mat'], 'tmp_theta');
    save_dump([setting_params.tmp_dir '/Estep/theta/theta.mat']);
    
    for s = 1:setting_params.num_sub
        cost_tmp = load_until_exist([setting_params.tmp_dir '/Estep/cost/sub' num2str(s) '.mat']);
        update_cost(:,s) = cost_tmp.cost; 
    
    end
    if(~exist([setting_params.tmp_dir '/inter_' num2str(Params.iter_inter) '/intra_'...
        num2str(Params.iter_intra) '/EMstep_iter' num2str(iter_em) '/cost']))
        mkdir([setting_params.tmp_dir '/inter_' num2str(Params.iter_inter) '/intra_'...
            num2str(Params.iter_intra) '/EMstep_iter' num2str(iter_em) '/cost']);
    end
    save([setting_params.tmp_dir '/inter_' num2str(Params.iter_inter) '/intra_'...
        num2str(Params.iter_intra) '/EMstep_iter' num2str(iter_em) '/cost/EMiter' num2str(iter_em)...
        '_cost.mat'],'update_cost');
    save_dump([setting_params.tmp_dir '/inter_' num2str(Params.iter_inter) '/intra_'...
        num2str(Params.iter_intra) '/EMstep_iter' num2str(iter_em) '/cost/EMiter' num2str(iter_em) '_cost.mat']);
    
    rmdir([setting_params.tmp_dir '/Estep'],'s');
    rmdir([setting_params.tmp_dir '/Mstep'],'s');
    
    % em stop criteria
    sub_set = find((abs(abs(update_cost-cost)./cost)>1e-4)==0);
    if(length(sub_set) == setting_params.num_sub)
        stop_em = 1;
        Params.cost_em = update_cost;
    end
    if(iter_em > 100)
        stop_em = 1;
        Params.cost_em = update_cost;
        warning('vem can not converge');
    end
    cost = update_cost;
    if(~exist([setting_params.tmp_dir '/inter_' num2str(Params.iter_inter) '/intra_'...
        num2str(Params.iter_intra) '/EMstep_iter' num2str(iter_em) '/converge_flag']))
        mkdir([setting_params.tmp_dir '/inter_' num2str(Params.iter_inter) '/intra_'...
            num2str(Params.iter_intra) '/EMstep_iter' num2str(iter_em) '/converge_flag']);
    end
    save([setting_params.tmp_dir '/inter_' num2str(Params.iter_inter) '/intra_'...
        num2str(Params.iter_intra) '/EMstep_iter' num2str(iter_em) '/converge_flag/iter_'...
        num2str(iter_em) '.mat'],'iter_em','stop_em');
    save_dump([setting_params.tmp_dir '/inter_' num2str(Params.iter_inter) '/intra_'...
        num2str(Params.iter_intra) '/EMstep_iter' num2str(iter_em) '/converge_flag/iter_' num2str(iter_em) '.mat']);
    toc;
end
fprintf('EM..Done\n');

end
 
function log_vmf = vmf_probability(X,nu,kappa)

% log of von Mises-Fisher distribution
% X: input data
% nu: mean direction
% kap: concentration parameter. kap is a 1xL vector

dim = size(X,2)-1;
log_vmf = bsxfun(@plus,Cdln(kappa,dim),bsxfun(@times,kappa,X*nu));

end

function out = Ad(in,D)
out = besseli(D/2,in) ./ besseli(D/2-1,in);
end

function out = Cdln(k,d,k0)

% Computes the logarithm of the partition function of vonMises-Fisher as
% a function of kappa

k = double(k);

sizek = size(k);
k = k(:);

out = (d/2-1).*log(k)-log(besseli((d/2-1)*ones(size(k)),k));
if(d<1200)
    k0 = 500;
elseif(d>=1200 && d<1800)
    k0 = 650;
else
    error('dimension is too high, need  to specify k0');
end
fk0 = (d/2-1).*log(k0)-log(besseli(d/2-1,k0));
nGrids = 1000;

maskof = find(k>k0);
nkof = length(maskof);

% The kappa values higher than the overflow

if nkof > 0

    kof = k(maskof);

    ofintv = (kof - k0)/nGrids;
    tempcnt = (1:nGrids) - 0.5;
    ks = k0 + repmat(tempcnt,nkof,1).*repmat(ofintv,1,nGrids);
    adsum = sum( 1./((0.5*(d-1)./ks) + sqrt(1+(0.5*(d-1)./ks).^2)) ,2);

    out(maskof) =  fk0 - ofintv .* adsum;

end

out = single(reshape(out,sizek));

end

function [outu] = invAd(D,rbar)

rbar = double(rbar);

outu = (D-1).*rbar./(1-rbar.^2) + D/(D-1).*rbar;

[i] = besseli(D/2-1,outu);

if ((i == Inf)||(isnan(i)) || (i==0))
    out = outu - D/(D-1)*rbar/2;
    exitflag = Inf;
else
    [outNew, fval exitflag]  = fzero(@(argum) Ad(argum,D)-rbar,outu);
    if exitflag == 1
        out = outNew;
    else
        out = outu - D/(D-1)*rbar/2;
    end
end

end

function lambda = CBIG_ArealMSHBM_initialize_concentration(D)

% find initialize point for concentration parameter with given feature dimension
% D: feature dimension

ini_flag = 0;
start_value = 50;
ini_loop = 0;
while (ini_flag == 0)
    ini_loop = ini_loop + 1;
    [inilambda,~,exitflag] = fzero(@(inputx) sign(inputx)*abs(besseli(D/2 - 1,inputx))-1e+10,...
         start_value,optimset('Display','off'));
    if (exitflag == 1)
        lambda = inilambda;
        ini_flag = 1;
    else
        start_value = start_value + 50;
    end
    if(ini_loop == 1000)
        error('Can not initialize lambda automatically, please manually set it');
    end
end
fprintf('initialize lambda with %.2f\n',lambda);
        
end

function out_var = load_until_exist(filename)

while(~exist([filename '.dump']))
    pause(1);
end
out_var = load(filename);

end

function save_dump(filename)

fclose(fopen([filename '.dump'],'w'));

end

function fetch_data(project_dir, num_session, num_sub, mesh, tmp_dir)

% read in input functional connectivity profiles
if(~isempty(strfind(mesh,'fs_LR_32k')))
    for t = 1:num_session
        data_profile = fullfile(project_dir, 'profile_list', 'training_set', ['sess' num2str(t) '.txt']);
        profile_name = table2cell(readtable(data_profile, 'Delimiter', ' ', 'ReadVariableNames', false));
        
        for i = 1:num_sub
            fprintf('Session %d...It is subj %d...\n',t,i);
            avg_file = profile_name{i,1};
            profile_list{i,t} = avg_file;
        end

    end
    save(fullfile(tmp_dir,'all_sub_profile_list.mat'),'profile_list');

elseif(~isempty(strfind(mesh,'fsaverage')))
    for t = 1:num_session
        lh_data_profile = fullfile(project_dir, 'profile_list', 'training_set', ['lh_sess' num2str(t) '.txt']);
        rh_data_profile = fullfile(project_dir, 'profile_list', 'training_set', ['rh_sess' num2str(t) '.txt']);
        lh_profile_name = table2cell(readtable(lh_data_profile, 'Delimiter', ' ', 'ReadVariableNames', false));
        rh_profile_name = table2cell(readtable(rh_data_profile, 'Delimiter', ' ', 'ReadVariableNames', false));

        for i = 1:num_sub
            fprintf('Session %d...It is subj %d...\n',t,i);
            lh_avg_file=lh_profile_name{i,1};
            lh_profile_list{i,t} = lh_avg_file;
            rh_avg_file=rh_profile_name{i,1};
            rh_profile_list{i,t} = rh_avg_file;

        end

    end
    save([tmp_dir '/all_sub_profile_list.mat'],'lh_profile_list','rh_profile_list');
end

end